/* Copyright (c) Microsoft Corporation. All rights reserved. */

// FixDocIndex.cs
//
// Performs some postprocessing on the documentation index generated by CodeDoc using
// ..\..\..\CodeDoc.xml.  Specifically, where the index contains both these entries:
//     <whatever> Class
//     <whatever> Class - Microsoft.SharePointLearningKit.Schema
// ...the second one is removed.
//
// The command-line argument is the path to Default_Index.htm.
//

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;

class Program
{
    static void Main(string[] args)
    {
        // the first argument is the path to Default_Index.htm
        string filePath = args[0];

        // load the HTML document from <filePath> into <introLines> and <xmlDocument>
        string[] introLines = new string[3];
        XmlDocument xmlDocument;
        XmlReaderSettings settings = new XmlReaderSettings();
        settings.ConformanceLevel = ConformanceLevel.Fragment;
        settings.ValidationFlags = XmlSchemaValidationFlags.None;
        settings.ProhibitDtd = false;
        using (StreamReader streamReader = new StreamReader(filePath))
        {
            for (int i = 0; i < introLines.Length; i++)
                introLines[i] = streamReader.ReadLine();
            using (XmlReader xmlReader = XmlReader.Create(streamReader, settings))
            {
                xmlDocument = new XmlDocument();
                xmlDocument.Load(xmlReader);
            }
        }

		// remove duplicate index entries
        XmlNamespaceManager nsm = new XmlNamespaceManager(xmlDocument.NameTable);
        nsm.AddNamespace("html", "http://www.w3.org/1999/xhtml");
        XmlNodeList nodeList = xmlDocument.SelectNodes(
            "/html:html/html:body/html:div/html:span", nsm);
        foreach (XmlNode spanNode in nodeList)
        {
			if (spanNode.InnerText.Contains("Class - Microsoft.SharePointLearningKit.Schema"))
				spanNode.ParentNode.ParentNode.RemoveChild(spanNode.ParentNode);
        }

        // save <introLines> and <xmlDocument> back to <filePath>
        byte[] fileContents;
        using (MemoryStream memoryStream = new MemoryStream())
        {
            using (StreamWriter streamWriter = new StreamWriter(memoryStream))
            {
                xmlDocument.Save(streamWriter);
                streamWriter.Flush();
                fileContents = memoryStream.ToArray();
            }
        }
        using (MemoryStream memoryStream = new MemoryStream(fileContents))
        {
            memoryStream.Seek(0, SeekOrigin.Begin);
            using (StreamReader streamReader = new StreamReader(memoryStream))
            {
                string skipLine = streamReader.ReadLine();
                using (StreamWriter streamWriter = new StreamWriter(filePath))
                {
                    for (int i = 0; i < introLines.Length; i++)
                        streamWriter.WriteLine(introLines[i]);
                    string line;
                    while ((line = streamReader.ReadLine()) != null)
                        streamWriter.WriteLine(line);
                }
            }
        }
    }
}

